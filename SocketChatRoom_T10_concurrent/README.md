### **简易聊天**

客户端将消息发给服务端，服务端等待转发给其他客户端。

每个客户端都需要服务器进行转发，双通等待。

双通：客户端发送数据到服务器接收通道 + 服务器回送消息发送通道。

每条通道因为堵塞只能使用异步线程实现。


##### 分析：

> 一个客户端：双通， > 2条线程
> 
>n个客户端，2n条线程
>
>服务器实际线程数量： 2n+


客户端数量较多时，
CPU消耗50%， 内存占用很高，线程数量爆发。


#### 优化：

1. 减少线程数量
2. 增加线程执行繁忙状态，减少线程空闲等待时间与线程切换时间
3. 内存，加客户端Buffer复用机制


#### 阻塞IO和非阻塞IO
NIO:
* Buffer 缓冲区，用于数据处理的基础单元，客户端发送与接收数据都需要通过Buffer转发进行。
* Channel 通道，类似于流，但偏向于数据的流通多样性。
* Selectors 选择器，处理客户端所有事件的分发器，用于管理事件。

* Buffer包括：
> ByteBuffer,CharBuffer,ShortBuffer,IntBuffer,LongBuffer,FloatBuffer,DoubleBuffer

* Channel包括：
> FileChannel,SocketChannel,DatagramChannel

Buffer为NIO按块操作提供了基础，数据按“块”传输。一个Buffer代表一块数据。

Buffer中其实是维护了一个数组。

可以从通道读取数据，也可以输出数据到通道，按块进行操作。

NIO可以并发异步读写数据。

##### NIO的API

Selector:向Selector注册一个事件，对应Channel的状态
Channel:Channel状态变化时，触发注册的事件
Buffer:

注册事件：
* SelectionKey.OP_CONNECT 连接就绪
* SelectionKey.OP_ACCEPT  接受就绪
* SelectionKey.OP_READ  读就绪
* SelectionKey.OP_WRITE  写就绪

Selector使用流程：
* open()方法开启一个选择器，给选择器注册需要关注的事件
* register() 将一个Channel注册到选择器，当选择器触发对应关注事件时，回调到Channel中，处理相关数据。
* select()/selectNow() 一个通道Channel，处理一个当前可用，待处理的通道数据。是阻塞操作。
* selectedKeys()拿到当前就绪的通道。

FileChannel不能用于Selector,因为FileChannel不能切换为非阻塞模式。


##### 【异步线程优化】- 监听与数据处理线程分离

##### 消息粘包

TCP本质上不会发生数据层面的粘包，但是上层业务层面可能发生粘包。

UDP不保证消息的完整性，所有UDP是可能发生丢包的。

TCP传输有顺序性，校验完整性。

问题复现：
1. 多消息粘包
2. 单消息不完整
3. 消息到达提醒重复触发，（读消息时未设置取消监听）

##### 如何有序地混传数据？
1. 数据传输加上开始结束标记
2. 数据传输使用固定头部信息
3. 混合方案：固定数据头，数据加密，数据描述

##### 文件传输与普通传输的区别
1. 最大的区别，文件数据bytes远大于普通数据bytes
2. 文件传输需分片，组装分片
3. 如何中途取消而不影响后续Packet的发送
4. 文件传输校验，保证数据准确性

##### 文件消息模型
1. 发送文件支持取消发送
2. 文件分段传输，增大传输容错率
3. 同一连接实现文件、普通消息优先级

实施：
> 1.根据文件大小计算分片，并读取数据到分片
>
> 2.分片数据固定格式打包发送
>
> 3.分片数据解析与分片组装
>
> 4.DisPatcher调度逻辑 


数据包分片，分为Frame,头帧包含Packet信息

数据分片在穿插帧的情况下进行Packet组合（难点）

#### 聊天室升级

1. 传输框架并发Bug修复
2. 三层缓冲区优化
3. 运行状态格式化输出
4. 消息调度优化（CPU,内存，速度）
5. 心跳包发送与消费

客户端与服务端需要达到百万个Socket连接
消息发送的调度用责任链模式管理，结构更简洁。

##### 网络传输心跳包的必要性

客户端是不需要知道服务器端的状态的，因为服务器端会随时推送消息给客户端，比如好友发来一条消息。

那么，CS模型中如何互相知晓状态？

一旦有客户端给服务器发消息，那服务端需要推送消息给其他客户端，所以，服务端需要知道当前的连接状态是否可用。
从理论来说，TCP的CS连接是客户端与服务器端直连，不需要心跳包。

但是，遇到程序崩溃或者防火墙拦截，连接会异常断开，这种情况可能不会经过四次挥手。
客户端或者服务端不会被通知连接已处于断开状态。那么造成的结果就是，发送数据的时候才发现连接已经不可用。

另一个引起连接异常断开的是网络运营商的NAT路由器，路由器的映射状态表会过期，从而引起连接断开。

NAT会将客户端的状态通过路由器进行映射，然后通过映射端口去连接服务器。
这个过程存在映射表过期的情况。

每个客户端与服务器通过局域网进行连接，每个客户端设备都有自己的局域网IP地址和端口。
路由器与服务端是通过外网IP进行连接的。信息的传输是通过路由器进行转发传输的。

综上所述，心跳包的作用：
就是用来告知客户端与服务端之间的连接状态；
通过定时发送消息，让中间运营商的NAT路由表得以维持，避免路由表过期带来的异常中断。

心跳策略选择：

TCP KeepAlive ACK 仅仅代表连接保持时间，不代表业务层是否可以消费数据。
KeepAlive间隔比NAT运营商路由表失效时间长的多，KeepAlive time更底层一些，KeepAlive可用不代表业务层的数据可以收发。

1. 心跳策略可以使用socket.sendUrgentData(0xFF)发送紧急消息，发送一个Int值的低8位。
但是这个消息发送到业务端，会影响业务层的收发效率。
2. 另一种是自定义消息帧Frame作为心跳包，将Frame的长度标识设置为0，设置类型标识，唯一标识，Flag。

##### 心跳包发送与消费

* 客户端发送心跳数据，服务器接收数据，但并不回送业务数据包，此时客户端依然会收到服务端的数据确认包ACK。

* 为了应对高并发的情况下带宽，服务端不必要回送心跳数据包，仅仅通过基本的ACK回送就可以了.

* 服务器想知道客户端的状态，会使用客户端心跳包发送时间间隔的10倍长的时间扫描客户端，进行客户端活跃性扫描，超出时间未活跃则自动关闭链接。

* 心跳包的定时发送是通过定时器进行调度。

##### Netty的心跳实现

Netty在管道初始化的时候添加了两个节点，一个是超时事件节点，一个是心跳节点。
利用定时超时机制检测。
























